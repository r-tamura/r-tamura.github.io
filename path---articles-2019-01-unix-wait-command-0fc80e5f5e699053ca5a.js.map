{"version":3,"sources":["webpack:///path---articles-2019-01-unix-wait-command-0fc80e5f5e699053ca5a.js","webpack:///./.cache/json/articles-2019-01-unix-wait-command.json"],"names":["webpackJsonp","361","module","exports","data","site","siteMetadata","siteUrl","title","authorName","authorDetail","githubId","twitterId","markdownRemark","html","frontmatter","tags","date","fields","slug","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,QAAA,mBAAAC,MAAA,SAAAC,WAAA,WAAAC,aAAA,yBAAAC,SAAA,WAAAC,UAAA,eAA8JC,gBAAmBC,KAAA,y7FAA2sDC,aAAkzCC,MAAA,0BAAAR,MAAA,gBAAAS,KAAA,oBAAoFC,QAAWC,KAAA,0CAAgDC,aAAgBD,KAAA","file":"path---articles-2019-01-unix-wait-command-0fc80e5f5e699053ca5a.js","sourcesContent":["webpackJsonp([98757849530672],{\n\n/***/ 361:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"siteUrl\":\"https://rtam.xyz\",\"title\":\"Rの技術メモ\",\"authorName\":\"r-tamura\",\"authorDetail\":\"Web関連多めのソフトウェアエンジニアです。\",\"githubId\":\"r-tamura\",\"twitterId\":\"r_tamura30\"}},\"markdownRemark\":{\"html\":\"<p>2019年最初の記事はUnixの<code>wait</code>コマンドについて。<code>wait</code>コマンドはLinuxに通常built-inで組み込まれているコマンドで、機能は<strong>実行されている他のプロセスの終了を待つ</strong>こと。 コマンド引数には待つ対象のプロセスIDを指定することができ、もし引数を指定しない場合は全ての子プロセスの終了を待つ。<code>wait</code>は現在の実行環境のジョブテーブルを参照するため、<code>cd</code>のようにシェルビルトインとして実装されている。(シェルビルトインは外部プログラムではなくシェル自体に組み込まれているコマンド<a href=\\\"https://en.wikipedia.org/wiki/Shell_builtin\\\">1</a>)</p>\\n<h1>基本的な使い方</h1>\\n<p><code>wait</code>コマンドこシンタックスは以下だ。 自分は複数の重い処理をバックグラウンドで同時に実行した場合の全プロセスの完了同期をするときに使う。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>wait [n]\\n\\n# n    : 待つ対象の プロセスID or ジョブID (現在実行されているバックグラウンドプロセスのジョブID)</code></pre>\\n      </div>\\n<h3>例1 指定したプロセスを待つ</h3>\\n<h4>サンプルプログラム1</h4>\\n<p>子プロセスが終了するまで、プロセスがブロッキングし、 子プロセスの返り値を自身の返り値とする。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>#!/usr/bin/env bash\\n\\nsuccess_process () {\\n  sleep 3\\n  true\\n}\\n\\nfail_process () {\\n  sleep 3\\n  return 100\\n}\\n\\nsuccess_process &\\npid1=$!\\necho \\\"waiting process 1\\\"\\nwait $pid1\\necho \\\"process 1 exited with $?\\\"\\n\\nfail_process &\\npid2=$!\\necho \\\"waiting process 2...\\\"\\nwait $pid2\\necho \\\"process 2 exited with $?\\\"</code></pre>\\n      </div>\\n<h4>Output</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>$ bash wait_1.sh\\nwaiting process 1\\nprocess 1 exited with 0    # 3秒後に0を返す\\nwaiting process 2...\\nprocess 2 exited with 100  # 3秒後に100を返す</code></pre>\\n      </div>\\n<h3>例2 全ての子プロセスの終了を待つ</h3>\\n<h4>サンプルプログラム2</h4>\\n<p>子プロセスが終了するまで、プロセスがブロッキングし、 子プロセスの返り値を自身の返り値とする。\\n重たいプロセスを想定した関数を5つ呼び出す。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>#!/usr/bin/env bash\\nheavey_process () {\\n  sleep $1\\n}\\n\\nfor i in {1..5}\\ndo\\n  # Run command in background\\n  heave5_process $i &\\ndone\\n\\nwait\\necho \\\"all process finished\\\"</code></pre>\\n      </div>\\n<h4>Output</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>$ bash wait_2.sh\\nall process finished   # ほぼ5秒後に終了</code></pre>\\n      </div>\\n<h3>例3 子プロセスが存在しない場合</h3>\\n<h4>サンプルプログラム3</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>#!/usr/bin/env bash\\n\\nsleep 5 &\\npid=$1\\nkill $1\\nwait $1\\necho $1 was terminated. exited with $?</code></pre>\\n      </div>\\n<h4>Output</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>$ bash wait_3.sh\\nwait_3.sh: line 6:    79 Terminated              sleep 5\\n79 was terminated. exited with 143               # すぐに終了</code></pre>\\n      </div>\\n<p>どうやら今回の環境ではプロセスが存在しない場合は143を返すよう。</p>\\n<h1>カーネルの観点から</h1>\\n<p>子プロセスは正常終了・異常終了にかかわらず、プロセスを終了するときに自身の親プロセスへSIGCHILDシグナルを送信する。親プロセスはシグナルを無視するかシグナルハンドラーを実行するかを選択できるが、デフォルト動作は無視となっている。</p>\\n<ul>\\n<li><a href=\\\"https://linuxhint.com/wait_command_linux/\\\">Wait Command in Linux – Linux Hint</a></li>\\n<li><a href=\\\"https://www.gnu.org/software/bash/manual/bashref.html#index-wait\\\">Bash Reference Manual</a></li>\\n<li>[<a href=\\\"https://en.wikipedia.org/wiki/Shell_builtin\\\">Shell builtin - Wikipedia</a></li>\\n</ul>\",\"frontmatter\":{\"tags\":[\"unix\",\"process\",\"shell\"],\"title\":\"Unixのwaitコマンド\",\"date\":\"18 January, 2019\"},\"fields\":{\"slug\":\"/articles/2019/01/unix-wait-command/\"}}},\"pathContext\":{\"slug\":\"/articles/2019/01/unix-wait-command/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-2019-01-unix-wait-command-0fc80e5f5e699053ca5a.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"siteUrl\":\"https://rtam.xyz\",\"title\":\"Rの技術メモ\",\"authorName\":\"r-tamura\",\"authorDetail\":\"Web関連多めのソフトウェアエンジニアです。\",\"githubId\":\"r-tamura\",\"twitterId\":\"r_tamura30\"}},\"markdownRemark\":{\"html\":\"<p>2019年最初の記事はUnixの<code>wait</code>コマンドについて。<code>wait</code>コマンドはLinuxに通常built-inで組み込まれているコマンドで、機能は<strong>実行されている他のプロセスの終了を待つ</strong>こと。 コマンド引数には待つ対象のプロセスIDを指定することができ、もし引数を指定しない場合は全ての子プロセスの終了を待つ。<code>wait</code>は現在の実行環境のジョブテーブルを参照するため、<code>cd</code>のようにシェルビルトインとして実装されている。(シェルビルトインは外部プログラムではなくシェル自体に組み込まれているコマンド<a href=\\\"https://en.wikipedia.org/wiki/Shell_builtin\\\">1</a>)</p>\\n<h1>基本的な使い方</h1>\\n<p><code>wait</code>コマンドこシンタックスは以下だ。 自分は複数の重い処理をバックグラウンドで同時に実行した場合の全プロセスの完了同期をするときに使う。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>wait [n]\\n\\n# n    : 待つ対象の プロセスID or ジョブID (現在実行されているバックグラウンドプロセスのジョブID)</code></pre>\\n      </div>\\n<h3>例1 指定したプロセスを待つ</h3>\\n<h4>サンプルプログラム1</h4>\\n<p>子プロセスが終了するまで、プロセスがブロッキングし、 子プロセスの返り値を自身の返り値とする。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>#!/usr/bin/env bash\\n\\nsuccess_process () {\\n  sleep 3\\n  true\\n}\\n\\nfail_process () {\\n  sleep 3\\n  return 100\\n}\\n\\nsuccess_process &\\npid1=$!\\necho \\\"waiting process 1\\\"\\nwait $pid1\\necho \\\"process 1 exited with $?\\\"\\n\\nfail_process &\\npid2=$!\\necho \\\"waiting process 2...\\\"\\nwait $pid2\\necho \\\"process 2 exited with $?\\\"</code></pre>\\n      </div>\\n<h4>Output</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>$ bash wait_1.sh\\nwaiting process 1\\nprocess 1 exited with 0    # 3秒後に0を返す\\nwaiting process 2...\\nprocess 2 exited with 100  # 3秒後に100を返す</code></pre>\\n      </div>\\n<h3>例2 全ての子プロセスの終了を待つ</h3>\\n<h4>サンプルプログラム2</h4>\\n<p>子プロセスが終了するまで、プロセスがブロッキングし、 子プロセスの返り値を自身の返り値とする。\\n重たいプロセスを想定した関数を5つ呼び出す。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>#!/usr/bin/env bash\\nheavey_process () {\\n  sleep $1\\n}\\n\\nfor i in {1..5}\\ndo\\n  # Run command in background\\n  heave5_process $i &\\ndone\\n\\nwait\\necho \\\"all process finished\\\"</code></pre>\\n      </div>\\n<h4>Output</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>$ bash wait_2.sh\\nall process finished   # ほぼ5秒後に終了</code></pre>\\n      </div>\\n<h3>例3 子プロセスが存在しない場合</h3>\\n<h4>サンプルプログラム3</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>#!/usr/bin/env bash\\n\\nsleep 5 &\\npid=$1\\nkill $1\\nwait $1\\necho $1 was terminated. exited with $?</code></pre>\\n      </div>\\n<h4>Output</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>$ bash wait_3.sh\\nwait_3.sh: line 6:    79 Terminated              sleep 5\\n79 was terminated. exited with 143               # すぐに終了</code></pre>\\n      </div>\\n<p>どうやら今回の環境ではプロセスが存在しない場合は143を返すよう。</p>\\n<h1>カーネルの観点から</h1>\\n<p>子プロセスは正常終了・異常終了にかかわらず、プロセスを終了するときに自身の親プロセスへSIGCHILDシグナルを送信する。親プロセスはシグナルを無視するかシグナルハンドラーを実行するかを選択できるが、デフォルト動作は無視となっている。</p>\\n<ul>\\n<li><a href=\\\"https://linuxhint.com/wait_command_linux/\\\">Wait Command in Linux – Linux Hint</a></li>\\n<li><a href=\\\"https://www.gnu.org/software/bash/manual/bashref.html#index-wait\\\">Bash Reference Manual</a></li>\\n<li>[<a href=\\\"https://en.wikipedia.org/wiki/Shell_builtin\\\">Shell builtin - Wikipedia</a></li>\\n</ul>\",\"frontmatter\":{\"tags\":[\"unix\",\"process\",\"shell\"],\"title\":\"Unixのwaitコマンド\",\"date\":\"18 January, 2019\"},\"fields\":{\"slug\":\"/articles/2019/01/unix-wait-command/\"}}},\"pathContext\":{\"slug\":\"/articles/2019/01/unix-wait-command/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-2019-01-unix-wait-command.json\n// module id = 361\n// module chunks = 98757849530672"],"sourceRoot":""}